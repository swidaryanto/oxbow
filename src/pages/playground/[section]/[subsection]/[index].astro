---
// Foundation
import BaseLayout from "@/layouts/BaseLayout.astro";
import Text from "@/components/fundations/typography/Text.astro";
import Playground from "@/components/playground/Playground.astro";
import Wrapper from "@/components/fundations/containers/Wrapper.astro";
import IconButton from "@/components/fundations/buttons/IconButton.astro";
import ChevronLeft from "@/components/fundations/icons/ChevronLeft.astro";
import ChevronRight from "@/components/fundations/icons/ChevronRight.astro";
// import DetailToolbarIsland from "@/components/playground/DetailToolbarIsland";
import type { ComponentInstance } from "astro";

type PlaygroundComponentModule = ComponentInstance & {
  description?: string;
  freeComponent?: boolean;
};

export async function getStaticPaths() {
  // Get all oxbow components
  const modules = import.meta.glob("@/components/oxbow/**/*.astro");
  const keys = Object.keys(modules);
  
  // Build paths for all components
  const paths = [];
  
  for (const key of keys) {
    // Extract section, subsection, and index from the path
    const pathParts = key
      .replace(/^.*?\/src\/components\/oxbow\//, "")
      .replace(/\.astro$/, "")
      .split("/");
    
    if (pathParts.length >= 3) {
      const section = pathParts[0];
      const subsection = pathParts[1];
      const fileName = pathParts[2];
      
      // Extract index from filename (e.g., "01" from "01.astro")
      const indexMatch = fileName.match(/^(\d+)/);
      const index = indexMatch ? indexMatch[1] : "1";
      
      paths.push({
        params: { section, subsection, index },
      });
    }
  }
  
  return paths;
}

// Parameters
const { section, subsection, index } = Astro.params;
const modules = import.meta.glob("@/components/oxbow/**/*.astro") as Record<
  string,
  () => Promise<PlaygroundComponentModule>
>;
const keys = Object.keys(modules);
const sectionRegex = new RegExp(`${section}/${subsection}/.+\\.astro$`, "i");
const sectionKeys = keys.filter((k) => k.match(sectionRegex));
sectionKeys.sort();
const currentKey = sectionKeys[parseInt(index) - 1];
const componentModule = currentKey ? await modules[currentKey]() : undefined;
const componentPath = `${section}/${subsection}/${index}`;

// Metadata from module exports
const componentDescription = componentModule?.description || "";
const freeComponent = componentModule?.freeComponent ?? true;

const leftPadZero = (numString: number) => numString.toString().padStart(2, "0");

const sectionLength = sectionKeys.length;

// Build category â†’ blocks map and counts for detail navigation
const triples = keys.map((k) => k.split("/").slice(-3)); // [section, subsection, file]
const subsByCat = Object.fromEntries(
  Array.from(new Set(triples.map(([sec]) => sec))).map((sec) => {
    const subs = Array.from(
      new Set(triples.filter(([s]) => s === sec).map(([, sub]) => sub))
    ).sort();
    return [sec, subs];
  })
);
const countsByCatSub = triples.reduce(
  (acc, [sec, sub]) => {
    const key = `${sec}/${sub}`;
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  },
  {} as Record<string, number>
);
---

<style is:global>
  html {
    overflow-y: auto;
    scrollbar-gutter: stable;
  }

  :where(html, body) {
    margin: 0;
    padding: 0;
    min-height: 0 !important;
    height: auto !important;
  }
  #oxbow-root {
    display: block;
  }
  #oxbow-root img {
    max-width: 100%;
    height: auto;
  }
</style>

<BaseLayout>
  <section class="relative">
    <Wrapper variant="standard" class="py-8 b">
      <div class="flex items-center gap-2">
        <Text
          tag="h1"
          variant="textBase"
          class="font-semibold tracking-tight capitalize text-zinc-900 dark:text-base-50"
        >
          {subsection.replace(/-/g, " ")}
        </Text>
      </div>
      <Text
        tag="p"
        variant="textSM"
        class="flex gap-1 text-zinc-500 dark:text-zinc-400 sr-only"
      >
        {
          componentDescription && (
            <span
              aria-hidden="true"
              class="hidden text-zinc-500 md:block dark:text-zinc-400"
            >
              /
            </span>
          )
        }
        {componentDescription}
      </Text>
    </Wrapper>
  </section>
  <section>
    <Wrapper
      variant="wide"
      class="relative py-8 border-y border-base-200 dark:border-base-800 2xl:border-x"
    >
      <Playground
        componentIndex={parseInt(index)}
        componentPath={componentPath}
        playgroundRef={`${section}-${subsection}-${index}`}
        initialTabIsCode={Astro.url.searchParams.get("tab") === "code"}
        navCat={section}
        navSub={subsection}
        navIdx={parseInt(index)}
        subsByCat={subsByCat}
        counts={countsByCatSub}
        prevHref={parseInt(index) === 1
          ? undefined
          : `/playground/${section}/${subsection}/${leftPadZero(parseInt(index) - 1)}`}
        nextHref={parseInt(index) === sectionLength
          ? undefined
          : `/playground/${section}/${subsection}/${leftPadZero(parseInt(index) + 1)}`}
        sectionLength={sectionLength}
      >
        <componentModule.default />
      </Playground>
    </Wrapper>
  </section>
</BaseLayout>

<script is:inline>
  // Parent-side listener: update iframe and container height based on messages from /iframe/* pages
  (function () {
    function setHeightById(id, height) {
      const ifr = document.getElementById(id);
      if (!ifr || !(ifr instanceof HTMLIFrameElement)) return;
      const n = Number(height) || 0;
      if (n <= 0) return; // ignore bogus early heights
      const target = n + "px";
      if (ifr.style.height !== target) ifr.style.height = target;
      const container = ifr.parentElement;
      if (container && container.style.height !== target)
        container.style.height = target;
    }

    window.addEventListener("message", (e) => {
      try {
        const data = e?.data || {};
        if (data.type === "oxbow-height" && data.id) {
          setHeightById(data.id, data.height);
        }
      } catch (_) {}
    });
  })();
</script>

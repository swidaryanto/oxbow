---
import IframeHead from "@/components/IframeHead.astro";

export async function getStaticPaths() {
  // Get all oxbow components
  const modules = import.meta.glob("@/components/oxbow/**/*.astro");
  const keys = Object.keys(modules);
  
  // Generate paths for all components
  const paths = keys.map((key) => {
    // Remove the src/components/ prefix and .astro extension
    const componentPath = key
      .replace(/^.*?\/src\/components\/oxbow\//, "")
      .replace(/\.astro$/, "");
    
    return {
      params: { componentPath: componentPath },
    };
  });
  
  return paths;
}

const { componentPath } = Astro.params;
const params = Astro.url.searchParams;
const context = params.get("context");

// Lazy module map, only load needed component
const modules = import.meta.glob("@/components/oxbow/**/*.astro");
const keys = Object.keys(modules);

// Normalize incoming param and try several matching strategies
const rawPath = Array.isArray(componentPath) ? componentPath.join("/") : componentPath || "";
const ensureExt = (p: string) => (p.endsWith(".astro") ? p : `${p}.astro`);
const relFromSrc = rawPath.replace(/^\/?src\//, "");
const relFromOxbow = rawPath.replace(/^\/?src\/components\/oxbow\//, "");
const onlyOxbow = rawPath.replace(/^.*?oxbow\//, "oxbow/");

const candidates = [
  rawPath,
  `/${rawPath}`,
  ensureExt(rawPath),
  relFromSrc,
  ensureExt(relFromSrc),
  relFromOxbow,
  ensureExt(relFromOxbow),
  `src/components/oxbow/${relFromOxbow}`,
  `/src/components/oxbow/${relFromOxbow}`,
  onlyOxbow,
  ensureExt(onlyOxbow),
];

let matchKey = undefined as string | undefined;
for (const c of candidates) {
  matchKey = keys.find((k) => k === c) || keys.find((k) => k.endsWith(c));
  if (matchKey) break;
}

const component = matchKey ? await modules[matchKey]() : undefined;
---

<html lang="en" class="selection:text-blue selection:bg-blue/5">
  <head>
    <IframeHead />
    <style>
      html,
      body {
        margin: 0 !important;
        padding: 0 !important;
        min-height: 0 !important;
        height: auto !important;
        box-sizing: border-box;
        transform: none !important;
        zoom: 1 !important;
        backface-visibility: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
    </style>
  </head>
  <body>
    {
      component ? (
        context === "card" ? (
          <div class="p-4 md:p-6">
            <component.default />
          </div>
        ) : (
          <component.default />
        )
      ) : (
        <div class="p-6 text-sm text-red-600 dark:text-red-400">
          Component not found for path: <code>{String(componentPath)}</code>
        </div>
      )
    }
    <script is:inline>
      (function () {
        const params = new URLSearchParams(window.location.search);
        const iframeId = params.get("iframeId") || "";
        const mode = (params.get('mode') || 'system').toLowerCase();

        const computeHeight = () => {
          try {
            const d = document;
            const b = d.body;
            const e = d.documentElement;
            return Math.max(
              b?.scrollHeight || 0,
              e?.scrollHeight || 0,
              b?.offsetHeight || 0,
              e?.offsetHeight || 0,
              b?.clientHeight || 0,
              e?.clientHeight || 0,
            );
          } catch (_) {
            return 0;
          }
        };

        let lastH = 0; let thTimer = null;
        const postHeightNow = () => {
          const h = computeHeight();
          if (Math.abs(h - lastH) < 1) return; lastH = h;
          try { parent.postMessage({ type: "oxbow-height", id: iframeId, height: h }, "*"); } catch (_) {}
        };
        const postHeight = () => {
          if (thTimer) return; thTimer = setTimeout(() => { thTimer = null; postHeightNow(); }, 33);
        };

        const postSoon = () => requestAnimationFrame(postHeight);

        function applyMode(m) {
          try {
            const html = document.documentElement;
            const body = document.body;
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const enableDark = m === 'dark' || (m === 'system' && prefersDark);
            html.classList.toggle('dark', enableDark);
            body?.classList.toggle('dark', enableDark);
            if (enableDark) { html.setAttribute('data-theme','dark'); body?.setAttribute('data-theme','dark'); }
            else { html.removeAttribute('data-theme'); body?.removeAttribute('data-theme'); }
          } catch (_) {}
        }

        // Apply mode from URL at startup
        applyMode(mode);

        // Track system changes if mode=system
        let mq; try {
          if (mode === 'system' && window.matchMedia) {
            mq = window.matchMedia('(prefers-color-scheme: dark)');
            const onChange = () => { applyMode('system'); postSoon(); };
            if (mq && 'addEventListener' in mq) mq.addEventListener('change', onChange);
            else if (mq && 'addListener' in mq) mq.addListener(onChange);
          }
        } catch(_) {}

        // Initial syncs
        window.addEventListener("DOMContentLoaded", postSoon);
        window.addEventListener("load", () => {
          postHeight();
          setTimeout(postHeight, 50);
          setTimeout(postHeight, 200);
          try { if (document.fonts && document.fonts.ready) document.fonts.ready.then(postSoon); } catch(_) {}
        });

        // Observe size and DOM changes
        try {
          const ro = new ResizeObserver(postSoon);
          ro.observe(document.documentElement);
          ro.observe(document.body);
        } catch (_) {}

        try {
          const mo = new MutationObserver(postSoon);
          mo.observe(document.documentElement, { childList: true, subtree: true, attributes: true });
        } catch (_) {}

        // Late-loading assets (images, fonts)
        document.querySelectorAll("img, video, iframe").forEach((el) => {
          if ("complete" in el && el.complete) return;
          el.addEventListener("load", postSoon, { once: true });
          el.addEventListener("error", postSoon, { once: true });
        });
        if (document.fonts && document.fonts.ready) {
          document.fonts.ready.then(postSoon).catch(() => {});
        }

        // Respond to parent explicit requests
        window.addEventListener("message", function (e) {
          try {
            if (!e || !e.data) return;
            if (e.data.type === "oxbow-request-height") {
              postHeight();
              return;
            }
            if (e.data.type === "oxbow-set-dark") {
              const enable = !!e.data.enable;
              try {
                const html = document.documentElement; const body = document.body;
                html.classList.toggle('dark', enable);
                body?.classList.toggle('dark', enable);
                if (enable) { html.setAttribute('data-theme','dark'); body?.setAttribute('data-theme','dark'); }
                else { html.removeAttribute('data-theme'); body?.removeAttribute('data-theme'); }
              } catch (_) {}
              // After theme change, recompute height soon
              setTimeout(postHeight, 20);
              setTimeout(postHeight, 120);
              return;
            }
          } catch (_) {}
        });
      })();
    </script>
  </body>
</html>
